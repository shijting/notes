## 位运算的概念：

** 位运算总共分为两大类： **

* 位运算，逻辑位运算
* 位移运算符

位运算操作**整数**，但是是操作整数的位

### 二进制转十进制口算技巧:

只看1为， 0位忽略， 然后把所有1那个位的次方加起来就是十进制

比如：二进制0010 可以这么理解看1后面有多少个0就是2的都是次方 ，2的1次方 也就是2了。

比如：0110 这么理解 二进制110 拆分为二进制100 + 二进制10 ， 2^2+ 2^1  = 6

只看1， 0忽略， 然后把所有1那个位的次方加起来就是十进制

1010 => (2^3) + (2^1) = 10

### 逻辑位运算：与、或、异或、非

#### &位与(二元运算)

按二进制位一个一个相与。两个位都是1，结果就是1， 否则为0
** 位与和逻辑位与 **
&是位与，&&是逻辑与
```go
var a int = 13 
var b int = 6 
var c int = a & b 
func main() {   
	fmt.Println(c)// 4 
}              
```
13的二进制是：00001101
6的二进制是：00000110
```
12&6
00001101
00000110
=
00000100
转成十进制：4
```

** 位与和逻辑与的区别： **

位与是两个操作数按照二进制位依次对应位相与，逻辑与是连个操作数作为整体相与的(234&&2 = 1, 0XFF&0xF1= 1)

** 总结：**

任何数(0,1) 和1位与无变化, 和0位与变成0

#### |位或(二元运算)
| 是位或，||是逻辑或
两个或者一个位是1，结果就是1，否则为0
13的二进制是：00001101
6的二进制是：  00000110
```
13|6
00001101
00000110
=
00001111
转成十进制：15
```
**总结：**

任何数(0,1) 和1位与变成1 和0位或无变化

#### ^位异或(二元运算)
golang 中如果是作为一元运算符出现，他的意思是按位取反
两个位不同，结果是1，否则为0
13的二进制是：00001101
6的二进制是：  00000110
```
13^6 或者写成 13 ^= 6
00001101
00000110
=
00001011
转成十进制：11
```
```go
func main() {   
    b := 13   
    b ^= 6   
    fmt.Println(b)// 11 
}              
```
** 总结： **

任何数(0,1) 和1位异或会取反, 和0位异或无变化

#### ~ 位非(一元运算)
操作** 一个数（一元运算）**，对位取反，0变成1,1变成0
~位取反，！逻辑取反
逻辑取反：只针对true 和false , !true = false , !0 =1, !1=0, !8345=0(非0就是true)

####  &|^总结（实战中会利用&1,|1,^1这些特性，必须要牢记）：

&：任何数(0,1) 和1位与无变化, 和0位与变成0

|：任何数(0,1) 和1位与变成1, 和0位或无变化

^：任何数(0,1) 和1位异或会取反, 和0位异或无变化

---

## 位移运算符(二元运算)

#### 二进制中的原码、反码、补码

**有符号数：** 对于有符号数而言，符号的正、负机器是无法识别的，但由于“正、负” 恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“负”，这样 符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符 号数。所以，在二进制中使用最高位（第一位）来表示符号，最高位是 0，表示正数；最高位是1，表示负数

```
100000000000000001111100              
```
** 无符号数：** 无符号数是针对二进制来讲的，无符号数的表数范围是非负数。全部二 进制均代表数值（所有位都用于表示数的大小），没有符号位。即第一 个"0"或"1"不表示正负 000000000000000001111100
** 对于有符号数而言的性质： **
1. 二进制的最高位是符号位：0表示正数，1表示负数
2. ** 正数**的原码、反码、补码都一样
3. **负数**的反码 = 它的原码符号位不变，其他位取反（0 ->1 ; 1->0 ）
4. 负数的补码 = 它的反码 +1
5. 0的反码、补码都是0
6. ** 在计算机运算的时候，都是以补码的方式来运算的**
7. 
** 有符号数运算案例 ** 
1. 正数相加： 例如：1+1 ，在计算机中运算如下： 	1的原码为： 00000000 00000000 00000000 00000001 反码： 00000000 00000000 00000000 00000001 补码： 00000000 00000000 00000000 00000001 两数的补码相加： 00000000 00000000 00000000 00000010（ 转换为10进制，正数的原码，反码，补码都一样） = 2
2. 正数相减： 例如：1 - 2，在计算机中运算如下： 在计算机中减运算其实是作为加运算来操作的，所以，1-2 = 1 + ( -2 ) 第一步：获取1的补码 00000000 00000000 00000000 00000001 第二步：获取-2的补码 -2的原码：10000000 00000000 00000000 00000010 -2的反码：11111111 11111111 11111111 11111101 -2的补码： 11111111 11111111 11111111 11111110 第三步：1的补码与-2的补码相加： 00000000 00000000 00000000 00000001 + 11111111 11111111 11111111 11111110 = 11111111 11111111 11111111 11111111
第四步：将计算结果的补码转换为原码，反其道而行之即可（如果想将 二进制转换为十进制，必须得到二进制的原码） 补码：11111111 11111111 11111111 11111111 = 反码：11111111 11111111 11111111 11111110 = 原码：10000000 00000000 00000000 00000001 第五步：将计算结果的二进制原码 转换 为十进制 二进制原码：10000000 00000000 00000000 00000001 = -1

** << 、>>、>>> 位移运算符 **

** << 左移运算符 左移一位 **

![0](https:////note.youdao.com/yws/res/9/WEBRESOURCEb3d376c74171b4fc6594324e8a97a149)

左移一位后的数值经过计算可以发现刚好值位移前数值的两倍，等价 于乘2操作，在很多情况下可以当做乘2使用，但是并不代表真正的乘2，在 一些特殊情况下并不等价

** 左移18位 **

![0](https:////note.youdao.com/yws/res/d/WEBRESOURCE4a967b4ae0495a6879803df43233399d)

此时二进制首位为1，此时数值为 -1058799616，同理，如果左位移 20位，则值为 59768832 又变成了正数

注意：所以根据这个规则，如果任意一个十进制的数左位移32位，右 边补位32个0，十进制岂不是都是0了？当然不是！！！ 当int 类型的数 据进行左移的时候，当左移的位数大于等于32位的时候，位数会先求 余数，然后用该余数进行左移，也就是说，如果真的左移32位的时 候，会先进行位数求余数，即为左移32位相当于左移0位 ，所以左移 33 的值和左移一位1 是一样的

** >> 右移运算符 **

** 100 带符号右移** 100 源码反码补码均为：00000000 00000000 00000000 01100100 ** 右移四位 ** ： 00000000 00000000 00000000 00000110 结果为：6 ** -100 带符号右移 **  -100原码： 10000000 00000000 00000000 01100100 -100补码： 保证符号位不变，其余位置取反并加1 	11111111 11111111 11111111 10011100 右移4位 ： 在高位补1

11111111 11111111 11111111 11111001

补码形式的移位完成后，结果不是移位后的结果，还需要进行变 换才行。其方法如下: 	保留符号位，然后按位取反： 10000000 00000000 00000000 00000110 	然后加1，即为所求数的原码： 10000000 00000000 00000000 00000111 结果为：-7

** >>> 无符号右移运算符 **

无符号右移运算符和右移运算符是一样的，不过无符号右移运算符在右移 的时候是补0的，而右移运算符是补符号位的（正数补0，负数补1） ** 100 无符号右移 4 位 ** 100 源码补码均为：00000000 00000000 00000000 01100100 右移四位： 00000000 00000000 00000000 00000110 结果为：6 ** -100 **无符号右移4位 -100原码： 10000000 00000000 00000000 01100100 -100补码： 保证符号位不变，其余位置取反并加1 11111111 11111111 11111111 10011100 无符号右移4位 ： 在高位补0 00001111 11111111 11111111 11111001 结果为：268435449

总结：正数的左移与右移、无符号右移、负数的无符号右移，就是相应 的补码移位所得，在高位补0即可 	有符号负数的右移，就是补码高位补1,然后按位取反加1即可


### 位移总结：

左位移: <<。 右位移：>>
- 对于无符号数，左移时右侧补0（相当于逻辑移位）
- 对于无符号数，右移时左侧补0（相当于逻辑移位）
- 对于有符号数，左移时右侧补0（叫算术移位，相当于逻辑移位)
- 对无有符号数，右移时左侧补符号位.（叫算术移位，如果是整数补0，负数补1)

---

## 实战：

### 位运算：

#### 1）特定位清零用&:

使用特征：`任何数(0,1) 和1位与无变化, 和0位与变成0`

如果希望将一个寄存器的某些特定位变成0而不影响其他为，可以构造一个合适的1和0组成的数和这个寄存器原来的值进行位与运算，就可以将特定位变成0。个人技巧：现将要&的数全部置为1,然后希望清零的为置为0(实在不会就用win10系统的计算器把二进制转成十六进制)

** 例子：**

假设原来32位寄存器中的值是`0x AAAAAAAA`（十六进制A的二进制是`1010`，`10101010101010101010101010101010`），我们希望将bit8~bit15清零而其他位不变，可以将原来值和`0xFFFF00FF`(十六进制F的二进制是`1111`, `11111111111111110000000011111111`)进行位与即可
```go
func main() {   
	fmt.Printf("%b\n", 0xaaaaaaaa&0xffff00ff) 
	// 10101010101010100000000010101010 
}              
```
#### 2）特定位置为1用|:

使用特征：`任何数(0,1) 和1位与变成1, 和0位或无变化`

我们需要构造一个要置1的特定位为1其他为0的二进制数，然后将原来的数与这个数进行位或运算即可

列子：
将一个值的bit4~bit8置为1，其他为不变， 可以用这个值和0x000000F0（缩写0xf0）进行位或运算

#### 3）特定位取反用^:

使用特征：`任何数(0,1) 和1位异或会取反, 和0位异或无变化`
我们需要构造一个要取反的特定位为1其他为0的二进制数，然后将原来的数与这个数进行位异或运算即可

#### 小知识点：

1. 十六进制的F代表二进制的1111,0代表0000




## 用位移(shift)构建特定的位
我们在写代码时不建议用计算器等构建特定的位，那么我们可以使用位移来构建特定的位
### 使用位移获取(构建)特定位为1的二进制数
1. 最简单的就是用位移来获取一个特定位为1的二进制数，譬如我们需要一个bit3~bit7为1(隐含的意思是其他位都为0)的二进制数。可以这样：bit3~bit7 有5个位，公式为(7-3+1)=5，那么我们先造一个5个1的二进制数为11111 转成十六进制为0x1f, 然后将0x1f左移3位 0x1f<<3

2. 更难一点的要求： 获取bit3-bit7为1，bit23~bit25为1其余位为0 ，就可以这么做 ((0x1f<<3) | (0x7<<23)) = 0x038000f8

   上面表达式含义：位或|说明这个数字由2部分组成，第一部分中左移3位说明第一部分从bit3开始，第一部分数字为0x1f说明这部分有5位，所以第一部分其实就是bit3到bit7;
   第二部分的解读方法同样的，可知第二部分其实就是bit23到bit25;
   所以两部分结合起来，这个数的特点就是: bit3~bit7和bit23~bit25为1，其余位全部为0

### 再结合位取反获取(构建)特定位为0的二进制数
这次我们要获取bit4~bit10位0， 其他位为1的数，要怎么做？
1. 可以使用上面 | 或位运算结合位移：也就bit0~bit3为1， bit11~bit31为1。(0xf<<0) | (0x1fffff<<11)。 这种办法连续为1的位数太多了，这个数据本身就不易读懂了，难构造。这种特定位(比较少)为0其他位(大部分)为1的。
2. 思路：先试图构造这个位相反的数，再取反得到这个数(譬如bit4~bit10 为0其余位为1，我们就可以构造bit4~bit10 为1，再按位取反：~(0x7f<<4)   )





## 实战
要置1用|，要清零用&，要取反用^。~和<<,>>用于构建特定二进制数
**注意**：`位取反` 的优先级 比`左、右移`要**高**。 "^" > "<<、>>"
**给定一个整型数a，设置a的bit3（置位，既置为1），保证其他位不变** 

```c
a = a | (1<<3) 或者 a |= (1<<3)
```
**给定一个整形数a，设置a的bit3~bit7，保持其他位不变。** 

```c
a = a | (0x1f << 3) 或者 a |= (0x1f << 3)
或者 a = a | (0b11111 << 3)
```
**给定一个整型数a，清除a的bit15(复位，既清零)，保证其他位不变。** 

```c

a = a & (~(1<<15)) 或者a &= (~(1<<15))
```
**给定一个整形数a，清除a的bit15~bit23，保持其他位不变。** 

```c
a = a & (~(0x1ff<<15)) 或者 a &= (~(0x1ff<<15))
// golang的写法
func main() {
	a := 0xffffffff
	a &= ^(0x1ff << 15)
	fmt.Printf("%b\n", a)
}
// output: 1111 1111 0000 0000 0111 1111 1111 1111
```
**给定一个整形数a，取出a的bit3~bit8。** 

```c
思路：
第一步：现将这个数bit3~bit8不变，其余位全部清零
	a &= 0x3f<<3
第二步：再将其右移三位得到结果
	a >>=3
```
**用c语言给一个寄存器的bit7~bit17赋值937（其余位不受影响)** 

```c
关键点：不能影响其他位，第二，我们并不知道原来bit7~bit17中的值
思路： 
	第一步：先将bit7~bit17 清零
		a &= ~(0x7ff << 7)
	第二步，将937写入bit7~bit17即可
		a |= 937 << 7
```
**用c语言将一个寄存器的bit7~～bit17中的值加17（其余位不受影响）。** 

```c
关键点：不知道bit7~～bit17原来的值是多少
思路：
	第一步，先读出原来bit7~～bit17的值
		tmp = (a & (0x7ff<<7))>>7
	第二步，给这个值加17
		tmp +=17
	第三步，将bit7~～bit17清零
		a &= ~(0x7ff<<7)
	第四步，将算出来的值写入bit7~～bit17
		a |= tmp<<7
```
**用c语言给一个寄存器的bit7~bit17赋值937，同时给bit21~bit25赋值17．** 

```c
第一种写法：
bit7~bit17赋值937
a &= ~(0x7ff << 7)
a |= 937 << 7
bit21~bit25赋值17
a &= ~(0x1f<<21)
a |= 17 << 21

第二种写法：

a &= ~(0x7ff << 7) | ~(0x1f<<21)

a |= (937 << 7 ) | (7 << 21)

```

**用宏定义将32位数x的第n位（右边起算，也就是bit0算第1位）置位**
```go
func main() {

	a := 0
	b := SetBitN(a, 4)
	fmt.Printf("%d\n", b)
	fmt.Printf("%b\n", b)
	
	a = 0xff // 1111 1111
	b = ClearBitN(a, 4)
	fmt.Printf("%d\n", b)
	fmt.Printf("%b\n", b)

	a = 0x0
	b = SetBitNM(a, 5, 8)
	fmt.Printf("%d\n", b)
	fmt.Printf("%b\n", b)

}

// SetBitN 用宏定义将32位数x的第n位（右边起算，也就是bit0算第1位）置位
func SetBitN(x, n int) int {
	x |= 1 << (n - 1)
	return x
}

// ClearBitN 用宏定义将32位数x的第n位（右边起算，也就是bit0算第1位）置位
func ClearBitN(x, n int) int {
	x &= ^(1 << (n - 1))
	return x
}

// SetBitNM 用宏定义将32位数x的第n位到第m位（右边起算，也就是bit0算第1位，m是高位）置位
// 假如，n=3, m=6， 题目的意思是将bit2到bit5置位，难点在要怎么设置 m-n +1个1
// 思路：第一步，先得到32个1: ~0
// 		第二步，将第一步得到的数右移x位即可得到m-n+1个1： ~0 >> (32 - (m-n+1))， 这一步可以使用截取变量的部分连续位的写法(下面一题)进行优化


func SetBitNM(x, n, m int) int {
	// todo n,m都必须大于0
	// 
	x |= (0xffffffff >> (32 - (m - n + 1))) << (n - 1)
	return x
}
```

**截取变量的部分连续位。例如：变量0x88 也就是10001000b, 若截取第2~4位，只值为100b = 4**
题目的意思是截取变量x的第n位到第m位
注意： `位取反~` 的优先级 比`左、右移`要高。 "^" > "<<、>>"
c语言中的写法：
```c
(x & ~(~0 << (m -n +1)) << (n-1)) >> (n-1)
```